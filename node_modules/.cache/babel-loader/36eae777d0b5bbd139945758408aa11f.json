{"ast":null,"code":"export const mainArr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\nexport const onlyRoutes = mainArr.map(item => {\n  return item.substring(0, 2);\n});\nvar onlyStartPos = mainArr.map(item => {\n  return item.substring(0, 1);\n});\nlet uniqueonlyStartPos = onlyStartPos.filter((item, i, ar) => ar.indexOf(item) === i);\nvar graphArr = {};\nuniqueonlyStartPos.forEach(startPos => {\n  graphArr[startPos] = [];\n  mainArr.forEach(route => {\n    if (route.charAt(0) === startPos) {\n      var newObj = {};\n      newObj[route.substring(1, 2)] = route.substring(2, route.length);\n      graphArr[startPos].push(newObj);\n    }\n  });\n}); // console.log(graphArr);\n\nconst convertArrayToObject = obj => {\n  var finalNeededObj = {}; // eslint-disable-next-line \n\n  Object.keys(obj).map(key => {\n    var eachObj = obj[key];\n    var eachPair = {};\n\n    for (var i = 0; i < eachObj.length; i++) {\n      // eslint-disable-next-line \n      Object.keys(eachObj[i]).map(key => {\n        eachPair[key] = eachObj[i][key];\n      });\n    }\n\n    finalNeededObj[key] = eachPair;\n  });\n  return finalNeededObj;\n};\n\nexport const parsedInput = convertArrayToObject(graphArr);\n\nfunction getPossiblePaths(start, end, graph, visitRoute = '', count = 0) {\n  const edges = graph[start];\n  console.log('edges', edges);\n\n  if (visitRoute && start === end) {\n    // We found the path\n    console.log(' visitRoute ', visitRoute + end + '=' + count);\n    return visitRoute + end + '=' + count;\n  }\n\n  if (!edges) {\n    // deadend\n    return '';\n  }\n\n  if (visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start) >= 0) {\n    // already visited route; we don't allow since it'll go in infiinte cycle\n    return '';\n  }\n\n  console.log('visitRoute after index', visitRoute);\n  visitRoute += start;\n  console.log('visitRoute after add start', visitRoute);\n  return Object.keys(edges).map(node => {\n    console.log(node); // No 0 cost routes should be included as per requirements\n\n    if (edges[node] === 0) {\n      return '';\n    } //node b // vr e //count \n\n\n    console.log(edges[node]);\n    console.log(count + edges[node]);\n    const route = getPossiblePaths(node, end, graph, visitRoute, count + edges[node]);\n    return route;\n  }).filter(empty => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/directedGraph.js"],"names":["mainArr","onlyRoutes","map","item","substring","onlyStartPos","uniqueonlyStartPos","filter","i","ar","indexOf","graphArr","forEach","startPos","route","charAt","newObj","length","push","convertArrayToObject","obj","finalNeededObj","Object","keys","key","eachObj","eachPair","parsedInput","getPossiblePaths","start","end","graph","visitRoute","count","edges","console","log","node","empty","join"],"mappings":"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","sourcesContent":["\nexport const mainArr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\nexport const onlyRoutes = mainArr.map((item) => {\n    return item.substring(0, 2);\n})\n\nvar onlyStartPos = mainArr.map((item) => {\n    return item.substring(0, 1);\n});\n\n\n\nlet uniqueonlyStartPos = onlyStartPos.filter((item, i, ar) => ar.indexOf(item) === i);\nvar graphArr = {};\nuniqueonlyStartPos.forEach((startPos) => {\n    graphArr[startPos] = [];\n    mainArr.forEach((route) => {\n        if (route.charAt(0) === startPos) {\n            var newObj = {};\n            newObj[route.substring(1, 2)] = route.substring(2, route.length);\n            graphArr[startPos].push(newObj);\n        }\n    })\n});\n\n// console.log(graphArr);\n\n\n\n\nconst convertArrayToObject = (obj) => {\n    var finalNeededObj = {};\n    // eslint-disable-next-line \n    Object.keys(obj).map((key) => {\n        var eachObj = obj[key];\n        var eachPair = {};\n        for (var i = 0; i < eachObj.length; i++) {\n            // eslint-disable-next-line \n            Object.keys(eachObj[i]).map((key) => {\n                eachPair[key] = eachObj[i][key]\n\n            })\n        }\n        finalNeededObj[key] = eachPair;\n    })\n    return finalNeededObj;\n};\n\n\nexport const parsedInput = convertArrayToObject(graphArr);\n\n\nfunction getPossiblePaths(start, end, graph, visitRoute = '', count = 0) {\n\n\n    const edges = graph[start];\n    console.log('edges', edges)\n    if (visitRoute && start === end) {\n        // We found the path\n        console.log(' visitRoute ', visitRoute + end + '=' + count)\n        return visitRoute + end + '=' + count;\n    }\n\n    if (!edges) {\n        // deadend\n        return '';\n    }\n\n    if (visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start) >= 0) {\n        // already visited route; we don't allow since it'll go in infiinte cycle\n        return '';\n    }\n\n    console.log('visitRoute after index', visitRoute)\n\n    visitRoute += start;\n    console.log('visitRoute after add start', visitRoute)\n\n\n    return Object.keys(edges).map((node) => {\n        console.log(node);\n        // No 0 cost routes should be included as per requirements\n        if (edges[node] === 0) {\n            return '';\n        }\n        //node b // vr e //count \n        console.log(edges[node])\n\n        console.log(count + edges[node])\n        const route = getPossiblePaths(node, end, graph, visitRoute, count + edges[node]);\n\n        return route;\n    }).filter((empty) => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}\n"]},"metadata":{},"sourceType":"module"}