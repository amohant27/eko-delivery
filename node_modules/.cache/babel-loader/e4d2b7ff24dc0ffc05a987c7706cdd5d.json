{"ast":null,"code":"export default function getPossiblePaths(start, end, graph, visitRoute = '', count = 0) {\n  const edges = graph[start];\n\n  if (visitRoute && start === end) {\n    // We found the path\n    return visitRoute + end + '=' + count;\n  }\n\n  if (!edges) {\n    // deadend\n    return '';\n  }\n\n  if (visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start) >= 0) {\n    // already visited route; we don't allow since it'll go in infiinte cycle\n    return '';\n  }\n\n  visitRoute += start;\n  return Object.keys(edges).map(node => {\n    // No 0 cost routes should be included as per requirements\n    if (edges[node] === 0) {\n      return '';\n    }\n\n    const route = getPossiblePaths(node, end, graph, visitRoute, count + edges[node]);\n    return route;\n  }).filter(empty => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/possiblePath.js"],"names":["getPossiblePaths","start","end","graph","visitRoute","count","edges","indexOf","length","Object","keys","map","node","route","filter","empty","join"],"mappings":"AAAA,eAAe,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,GAAjC,EAAsCC,KAAtC,EAA6CC,UAAU,GAAG,EAA1D,EAA8DC,KAAK,GAAG,CAAtE,EAAyE;AACpF,QAAMC,KAAK,GAAGH,KAAK,CAACF,KAAD,CAAnB;;AACA,MAAIG,UAAU,IAAIH,KAAK,KAAKC,GAA5B,EAAiC;AAC7B;AACA,WAAOE,UAAU,GAAGF,GAAb,GAAmB,GAAnB,GAAyBG,KAAhC;AACH;;AAED,MAAI,CAACC,KAAL,EAAY;AACR;AACA,WAAO,EAAP;AACH;;AAED,MAAIF,UAAU,CAACG,OAAX,CAAmBH,UAAU,CAACA,UAAU,CAACI,MAAX,GAAoB,CAArB,CAAV,GAAoCP,KAAvD,KAAiE,CAArE,EAAwE;AACpE;AACA,WAAO,EAAP;AACH;;AAGDG,EAAAA,UAAU,IAAIH,KAAd;AAGA,SAAOQ,MAAM,CAACC,IAAP,CAAYJ,KAAZ,EAAmBK,GAAnB,CAAwBC,IAAD,IAAU;AACpC;AACA,QAAIN,KAAK,CAACM,IAAD,CAAL,KAAgB,CAApB,EAAuB;AACnB,aAAO,EAAP;AACH;;AACD,UAAMC,KAAK,GAAGb,gBAAgB,CAACY,IAAD,EAAOV,GAAP,EAAYC,KAAZ,EAAmBC,UAAnB,EAA+BC,KAAK,GAAGC,KAAK,CAACM,IAAD,CAA5C,CAA9B;AAEA,WAAOC,KAAP;AACH,GARM,EAQJC,MARI,CAQIC,KAAD,IAAW,CAAC,CAACA,KARhB,EAQuBC,IARvB,CAQ4B,GAR5B,CAAP,CArBoF,CA6B3C;AAC5C","sourcesContent":["export default function getPossiblePaths(start, end, graph, visitRoute = '', count = 0) {\n    const edges = graph[start];\n    if (visitRoute && start === end) {\n        // We found the path\n        return visitRoute + end + '=' + count;\n    }\n\n    if (!edges) {\n        // deadend\n        return '';\n    }\n\n    if (visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start) >= 0) {\n        // already visited route; we don't allow since it'll go in infiinte cycle\n        return '';\n    }\n\n\n    visitRoute += start;\n\n\n    return Object.keys(edges).map((node) => {\n        // No 0 cost routes should be included as per requirements\n        if (edges[node] === 0) {\n            return '';\n        }       \n        const route = getPossiblePaths(node, end, graph, visitRoute, count + edges[node]);\n\n        return route;\n    }).filter((empty) => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}\n"]},"metadata":{},"sourceType":"module"}