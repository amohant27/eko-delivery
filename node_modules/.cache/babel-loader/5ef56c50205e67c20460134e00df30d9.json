{"ast":null,"code":"import _ from 'lodash';\nexport const mainArr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\nexport const onlyRoutes = mainArr.map(item => {\n  return item.substring(0, 2);\n});\nvar onlyStartPos = mainArr.map(item => {\n  return item.substring(0, 1);\n});\nlet uniqueonlyStartPos = onlyStartPos.filter((item, i, ar) => ar.indexOf(item) === i);\nvar graphArr = {};\nuniqueonlyStartPos.forEach(startPos => {\n  graphArr[startPos] = [];\n  mainArr.forEach(route => {\n    if (route.charAt(0) === startPos) {\n      var newObj = {};\n      newObj[route.substring(1, 2)] = route.substring(2, route.length);\n      graphArr[startPos].push(newObj);\n    }\n  });\n});\n\nconst convertArrayToObject = obj => {\n  var finalNeededObj = {}; // eslint-disable-next-line \n\n  Object.keys(obj).map(key => {\n    var eachObj = obj[key];\n    var eachPair = {};\n\n    for (var i = 0; i < eachObj.length; i++) {\n      // eslint-disable-next-line \n      Object.keys(eachObj[i]).map(key => {\n        eachPair[key] = eachObj[i][key];\n      });\n    }\n\n    finalNeededObj[key] = eachPair;\n  });\n  return finalNeededObj;\n};\n\nexport const parsedInput = convertArrayToObject(graphArr);\nconst inputRoutesStr = 'AB1, AC4, AD10, BE3, CD4, CF2, DE1, EB3, EA2, FD1';\n\nfunction createGraph(inputRoutesStr) {\n  let routesGraph = {};\n\n  const inputRoutes = _.map(inputRoutesStr.split(','), _.trim);\n\n  _.forEach(inputRoutes, route => {\n    let fromTown = route.charAt(0).toUpperCase();\n    let toTown = route.charAt(1).toUpperCase();\n    let cost = parseInt(route.substr(2));\n\n    if (cost !== 0) {\n      if (_.has(routesGraph, fromTown)) {\n        routesGraph[fromTown].push({\n          [toTown]: cost\n        });\n      } else {\n        routesGraph[fromTown] = [{\n          [toTown]: cost\n        }];\n      }\n    }\n  });\n\n  return routesGraph;\n}\n\nconsole.log(createGraph(inputRoutesStr));\n\nfunction findRoutes(routeCovered, isVisitedNode, fromTown, toTown, maxStops, currentStops, aggDeliveryCost, currentCost, maxDeliveryCost, sameRoute) {\n  // summation cost\n  aggDeliveryCost = aggDeliveryCost + currentCost; // Initialization : routeRepeat - using if sameRoute is allowed twice or not \n  // Using {1} if same route is not allowed\n  // Using {3} if same route is allowed\n\n  let routeRepeat = 1; // If same route is allowed change condition - anything greater than 2\n\n  if (sameRoute) {\n    routeRepeat = 3;\n  } // Do not bother about empty route covered\n\n\n  if (routeCovered.trim().length > 0) {\n    // Marking the current path while traversel so that it should not run into stack overflow.\n    if (isVisitedNode[routeCovered]) {\n      isVisitedNode[routeCovered]++;\n    } else {\n      isVisitedNode[routeCovered] = 1;\n    }\n\n    if (isVisitedNode[routeCovered] > routeRepeat) {\n      return;\n    }\n  } // If aggregate cost is greater than upper cost limit return\n\n\n  if (aggDeliveryCost >= maxDeliveryCost) {\n    return;\n  } // Check if both from and to towns are same.(Destination reached)\n\n\n  if (fromTown == toTown) {\n    this.possibleRoutes++; // Increase number of possible routes\n\n    if (aggDeliveryCost <= this.cheapestDelivery) {\n      this.cheapestDelivery = aggDeliveryCost;\n    } // If same route is allowed then do not return - let the program continue\n\n\n    if (!sameRoute) return;\n  } // If number of stops till now is greater than upper stops limit return\n\n\n  if (currentStops >= maxStops) {\n    return;\n  } // Increase number of stops till now\n\n\n  currentStops++; // Fetch the towns linked to fromTown from routesGraph created earlier.\n\n  let towns = this.routesGraph[fromTown]; // Loop over towns and do recursion.\n\n  for (let curr of towns) {\n    let cT = Object.keys(curr)[0];\n    let currentCost = curr[cT];\n    routeCovered = fromTown + cT;\n    this.findRoutes(routeCovered, isVisitedNode, cT, toTown, maxStops, currentStops, aggDeliveryCost, currentCost, maxDeliveryCost, sameRoute); // Un-Marking current path \n\n    isVisitedNode[routeCovered]--;\n\n    if (isVisitedNode[routeCovered] < 0) {\n      isVisitedNode[routeCovered] = 0;\n    }\n  }\n}\n\nfunction findNumberPossibleRoutes(start, dest, stops, sameRoute, maxDeliveryCost) {\n  let fromTown = start || '';\n  let toTown = dest || '';\n  sameRoute = sameRoute || false;\n  maxDeliveryCost = maxDeliveryCost || Number.MAX_SAFE_INTEGER;\n  let maxStops = stops || Number.MAX_SAFE_INTEGER;\n  this.possibleRoutes = 0;\n  this.cheapestDelivery = Number.MAX_SAFE_INTEGER; // Checking is one of the town is empty\n\n  if (fromTown.trim().length === 0 || toTown.trim().length === 0) return 0;\n  fromTown = fromTown.toUpperCase();\n  toTown = toTown.toUpperCase();\n  let routes = this.routesGraph[fromTown];\n  let isVisitedNode = [];\n  let pathRoute = '';\n\n  for (let curr of routes) {\n    let currentTown = Object.keys(curr)[0];\n    let currentStops = 1;\n    let dC = curr[currentTown];\n    this.findRoutes(pathRoute, isVisitedNode, currentTown, toTown, maxStops, currentStops, dC, 0, maxDeliveryCost, sameRoute);\n  }\n\n  return this.possibleRoutes;\n}\n\nfindNumberPossibleRoutes('E', 'D', 4, true, 0);","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/directedGraph.js"],"names":["_","mainArr","onlyRoutes","map","item","substring","onlyStartPos","uniqueonlyStartPos","filter","i","ar","indexOf","graphArr","forEach","startPos","route","charAt","newObj","length","push","convertArrayToObject","obj","finalNeededObj","Object","keys","key","eachObj","eachPair","parsedInput","inputRoutesStr","createGraph","routesGraph","inputRoutes","split","trim","fromTown","toUpperCase","toTown","cost","parseInt","substr","has","console","log","findRoutes","routeCovered","isVisitedNode","maxStops","currentStops","aggDeliveryCost","currentCost","maxDeliveryCost","sameRoute","routeRepeat","possibleRoutes","cheapestDelivery","towns","curr","cT","findNumberPossibleRoutes","start","dest","stops","Number","MAX_SAFE_INTEGER","routes","pathRoute","currentTown","dC"],"mappings":"AAAA,OAAOA,CAAP,MAAc,QAAd;AAGA,OAAO,MAAMC,OAAO,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,KAA9B,EAAqC,KAArC,EAA4C,KAA5C,EAAmD,KAAnD,EAA0D,KAA1D,EAAiE,KAAjE,CAAhB;AACP,OAAO,MAAMC,UAAU,GAAGD,OAAO,CAACE,GAAR,CAAaC,IAAD,IAAU;AAC5C,SAAOA,IAAI,CAACC,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAP;AACH,CAFyB,CAAnB;AAIP,IAAIC,YAAY,GAAGL,OAAO,CAACE,GAAR,CAAaC,IAAD,IAAU;AACrC,SAAOA,IAAI,CAACC,SAAL,CAAe,CAAf,EAAkB,CAAlB,CAAP;AACH,CAFkB,CAAnB;AAMA,IAAIE,kBAAkB,GAAGD,YAAY,CAACE,MAAb,CAAoB,CAACJ,IAAD,EAAOK,CAAP,EAAUC,EAAV,KAAiBA,EAAE,CAACC,OAAH,CAAWP,IAAX,MAAqBK,CAA1D,CAAzB;AACA,IAAIG,QAAQ,GAAG,EAAf;AACAL,kBAAkB,CAACM,OAAnB,CAA4BC,QAAD,IAAc;AACrCF,EAAAA,QAAQ,CAACE,QAAD,CAAR,GAAqB,EAArB;AACAb,EAAAA,OAAO,CAACY,OAAR,CAAiBE,KAAD,IAAW;AACvB,QAAIA,KAAK,CAACC,MAAN,CAAa,CAAb,MAAoBF,QAAxB,EAAkC;AAC9B,UAAIG,MAAM,GAAG,EAAb;AACAA,MAAAA,MAAM,CAACF,KAAK,CAACV,SAAN,CAAgB,CAAhB,EAAmB,CAAnB,CAAD,CAAN,GAAgCU,KAAK,CAACV,SAAN,CAAgB,CAAhB,EAAmBU,KAAK,CAACG,MAAzB,CAAhC;AACAN,MAAAA,QAAQ,CAACE,QAAD,CAAR,CAAmBK,IAAnB,CAAwBF,MAAxB;AACH;AACJ,GAND;AAOH,CATD;;AAcA,MAAMG,oBAAoB,GAAIC,GAAD,IAAS;AAClC,MAAIC,cAAc,GAAG,EAArB,CADkC,CAElC;;AACAC,EAAAA,MAAM,CAACC,IAAP,CAAYH,GAAZ,EAAiBlB,GAAjB,CAAsBsB,GAAD,IAAS;AAC1B,QAAIC,OAAO,GAAGL,GAAG,CAACI,GAAD,CAAjB;AACA,QAAIE,QAAQ,GAAG,EAAf;;AACA,SAAK,IAAIlB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiB,OAAO,CAACR,MAA5B,EAAoCT,CAAC,EAArC,EAAyC;AACrC;AACAc,MAAAA,MAAM,CAACC,IAAP,CAAYE,OAAO,CAACjB,CAAD,CAAnB,EAAwBN,GAAxB,CAA6BsB,GAAD,IAAS;AACjCE,QAAAA,QAAQ,CAACF,GAAD,CAAR,GAAgBC,OAAO,CAACjB,CAAD,CAAP,CAAWgB,GAAX,CAAhB;AAEH,OAHD;AAIH;;AACDH,IAAAA,cAAc,CAACG,GAAD,CAAd,GAAsBE,QAAtB;AACH,GAXD;AAYA,SAAOL,cAAP;AACH,CAhBD;;AAmBA,OAAO,MAAMM,WAAW,GAAGR,oBAAoB,CAACR,QAAD,CAAxC;AAIP,MAAMiB,cAAc,GAAG,mDAAvB;;AACA,SAASC,WAAT,CAAqBD,cAArB,EAAqC;AACjC,MAAIE,WAAW,GAAG,EAAlB;;AACA,QAAMC,WAAW,GAAGhC,CAAC,CAACG,GAAF,CAAM0B,cAAc,CAACI,KAAf,CAAqB,GAArB,CAAN,EAAiCjC,CAAC,CAACkC,IAAnC,CAApB;;AACAlC,EAAAA,CAAC,CAACa,OAAF,CAAUmB,WAAV,EAAwBjB,KAAD,IAAW;AAC9B,QAAIoB,QAAQ,GAAGpB,KAAK,CAACC,MAAN,CAAa,CAAb,EAAgBoB,WAAhB,EAAf;AACA,QAAIC,MAAM,GAAGtB,KAAK,CAACC,MAAN,CAAa,CAAb,EAAgBoB,WAAhB,EAAb;AACA,QAAIE,IAAI,GAAGC,QAAQ,CAACxB,KAAK,CAACyB,MAAN,CAAa,CAAb,CAAD,CAAnB;;AACA,QAAIF,IAAI,KAAK,CAAb,EAAgB;AACZ,UAAItC,CAAC,CAACyC,GAAF,CAAMV,WAAN,EAAmBI,QAAnB,CAAJ,EAAkC;AAC9BJ,QAAAA,WAAW,CAACI,QAAD,CAAX,CAAsBhB,IAAtB,CAA2B;AAAE,WAACkB,MAAD,GAAUC;AAAZ,SAA3B;AACH,OAFD,MAEO;AACHP,QAAAA,WAAW,CAACI,QAAD,CAAX,GAAwB,CAAC;AAAE,WAACE,MAAD,GAAUC;AAAZ,SAAD,CAAxB;AACH;AACJ;AAEJ,GAZD;;AAaA,SAAOP,WAAP;AACH;;AAEDW,OAAO,CAACC,GAAR,CAAYb,WAAW,CAACD,cAAD,CAAvB;;AAIA,SAASe,UAAT,CAAoBC,YAApB,EAAkCC,aAAlC,EAAiDX,QAAjD,EAA2DE,MAA3D,EAAmEU,QAAnE,EAA6EC,YAA7E,EAA2FC,eAA3F,EAA4GC,WAA5G,EAAyHC,eAAzH,EAA0IC,SAA1I,EAAqJ;AAEjJ;AACAH,EAAAA,eAAe,GAAGA,eAAe,GAAGC,WAApC,CAHiJ,CAMjJ;AACA;AACA;;AACA,MAAIG,WAAW,GAAG,CAAlB,CATiJ,CAWjJ;;AAEA,MAAID,SAAJ,EAAe;AACXC,IAAAA,WAAW,GAAG,CAAd;AACH,GAfgJ,CAiBjJ;;;AACA,MAAIR,YAAY,CAACX,IAAb,GAAoBhB,MAApB,GAA6B,CAAjC,EAAoC;AAEhC;AACA,QAAI4B,aAAa,CAACD,YAAD,CAAjB,EAAiC;AAC7BC,MAAAA,aAAa,CAACD,YAAD,CAAb;AACH,KAFD,MAEO;AACHC,MAAAA,aAAa,CAACD,YAAD,CAAb,GAA8B,CAA9B;AACH;;AAGD,QAAIC,aAAa,CAACD,YAAD,CAAb,GAA8BQ,WAAlC,EAA+C;AAC3C;AACH;AAEJ,GAhCgJ,CAiCjJ;;;AACA,MAAIJ,eAAe,IAAIE,eAAvB,EAAwC;AACpC;AACH,GApCgJ,CAsCjJ;;;AACA,MAAIhB,QAAQ,IAAIE,MAAhB,EAAwB;AACpB,SAAKiB,cAAL,GADoB,CACoB;;AACxC,QAAIL,eAAe,IAAI,KAAKM,gBAA5B,EAA8C;AAC1C,WAAKA,gBAAL,GAAwBN,eAAxB;AACH,KAJmB,CAMpB;;;AACA,QAAI,CAACG,SAAL,EACI;AAEP,GAjDgJ,CAmDjJ;;;AACA,MAAIJ,YAAY,IAAID,QAApB,EAA8B;AAC1B;AACH,GAtDgJ,CAuDjJ;;;AACAC,EAAAA,YAAY,GAxDqI,CA0DjJ;;AACA,MAAIQ,KAAK,GAAG,KAAKzB,WAAL,CAAiBI,QAAjB,CAAZ,CA3DiJ,CA6DjJ;;AACA,OAAK,IAAIsB,IAAT,IAAiBD,KAAjB,EAAwB;AACpB,QAAIE,EAAE,GAAGnC,MAAM,CAACC,IAAP,CAAYiC,IAAZ,EAAkB,CAAlB,CAAT;AACA,QAAIP,WAAW,GAAGO,IAAI,CAACC,EAAD,CAAtB;AAGAb,IAAAA,YAAY,GAAGV,QAAQ,GAAGuB,EAA1B;AACA,SAAKd,UAAL,CAAgBC,YAAhB,EAA8BC,aAA9B,EAA6CY,EAA7C,EAAiDrB,MAAjD,EAAyDU,QAAzD,EAAmEC,YAAnE,EAAiFC,eAAjF,EAAkGC,WAAlG,EAA+GC,eAA/G,EAAgIC,SAAhI,EANoB,CAQpB;;AACAN,IAAAA,aAAa,CAACD,YAAD,CAAb;;AACA,QAAIC,aAAa,CAACD,YAAD,CAAb,GAA8B,CAAlC,EAAqC;AACjCC,MAAAA,aAAa,CAACD,YAAD,CAAb,GAA8B,CAA9B;AACH;AAEJ;AAEJ;;AAGD,SAASc,wBAAT,CAAkCC,KAAlC,EAAyCC,IAAzC,EAA+CC,KAA/C,EAAsDV,SAAtD,EAAiED,eAAjE,EAAiF;AAC7E,MAAIhB,QAAQ,GAAGyB,KAAK,IAAI,EAAxB;AACA,MAAIvB,MAAM,GAAGwB,IAAI,IAAI,EAArB;AACCT,EAAAA,SAAS,GAAGA,SAAS,IAAI,KAAzB;AACAD,EAAAA,eAAe,GAAGA,eAAe,IAAIY,MAAM,CAACC,gBAA5C;AACD,MAAIjB,QAAQ,GAAGe,KAAK,IAAIC,MAAM,CAACC,gBAA/B;AAGA,OAAKV,cAAL,GAAsB,CAAtB;AACA,OAAKC,gBAAL,GAAwBQ,MAAM,CAACC,gBAA/B,CAT6E,CAW7E;;AACA,MAAI7B,QAAQ,CAACD,IAAT,GAAgBhB,MAAhB,KAA2B,CAA3B,IAAgCmB,MAAM,CAACH,IAAP,GAAchB,MAAd,KAAyB,CAA7D,EACI,OAAO,CAAP;AACJiB,EAAAA,QAAQ,GAAGA,QAAQ,CAACC,WAAT,EAAX;AACAC,EAAAA,MAAM,GAAGA,MAAM,CAACD,WAAP,EAAT;AAEA,MAAI6B,MAAM,GAAG,KAAKlC,WAAL,CAAiBI,QAAjB,CAAb;AACA,MAAIW,aAAa,GAAG,EAApB;AAEA,MAAIoB,SAAS,GAAG,EAAhB;;AACA,OAAK,IAAIT,IAAT,IAAiBQ,MAAjB,EAAyB;AACrB,QAAIE,WAAW,GAAG5C,MAAM,CAACC,IAAP,CAAYiC,IAAZ,EAAkB,CAAlB,CAAlB;AACA,QAAIT,YAAY,GAAG,CAAnB;AACA,QAAIoB,EAAE,GAAGX,IAAI,CAACU,WAAD,CAAb;AACA,SAAKvB,UAAL,CAAgBsB,SAAhB,EAA2BpB,aAA3B,EAA0CqB,WAA1C,EAAuD9B,MAAvD,EAA+DU,QAA/D,EAAyEC,YAAzE,EAAuFoB,EAAvF,EAA2F,CAA3F,EAA8FjB,eAA9F,EAA+GC,SAA/G;AACH;;AACD,SAAO,KAAKE,cAAZ;AACH;;AAEDK,wBAAwB,CAAC,GAAD,EAAM,GAAN,EAAU,CAAV,EAAY,IAAZ,EAAiB,CAAjB,CAAxB","sourcesContent":["import _ from 'lodash';\n\n\nexport const mainArr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\nexport const onlyRoutes = mainArr.map((item) => {\n    return item.substring(0, 2);\n})\n\nvar onlyStartPos = mainArr.map((item) => {\n    return item.substring(0, 1);\n});\n\n\n\nlet uniqueonlyStartPos = onlyStartPos.filter((item, i, ar) => ar.indexOf(item) === i);\nvar graphArr = {};\nuniqueonlyStartPos.forEach((startPos) => {\n    graphArr[startPos] = [];\n    mainArr.forEach((route) => {\n        if (route.charAt(0) === startPos) {\n            var newObj = {};\n            newObj[route.substring(1, 2)] = route.substring(2, route.length);\n            graphArr[startPos].push(newObj);\n        }\n    })\n});\n\n\n\n\nconst convertArrayToObject = (obj) => {\n    var finalNeededObj = {};\n    // eslint-disable-next-line \n    Object.keys(obj).map((key) => {\n        var eachObj = obj[key];\n        var eachPair = {};\n        for (var i = 0; i < eachObj.length; i++) {\n            // eslint-disable-next-line \n            Object.keys(eachObj[i]).map((key) => {\n                eachPair[key] = eachObj[i][key]\n\n            })\n        }\n        finalNeededObj[key] = eachPair;\n    })\n    return finalNeededObj;\n};\n\n\nexport const parsedInput = convertArrayToObject(graphArr);\n\n\n\nconst inputRoutesStr = 'AB1, AC4, AD10, BE3, CD4, CF2, DE1, EB3, EA2, FD1';\nfunction createGraph(inputRoutesStr) {\n    let routesGraph = {}\n    const inputRoutes = _.map(inputRoutesStr.split(','), _.trim);\n    _.forEach(inputRoutes, (route) => {\n        let fromTown = route.charAt(0).toUpperCase();\n        let toTown = route.charAt(1).toUpperCase();\n        let cost = parseInt(route.substr(2));\n        if (cost !== 0) {\n            if (_.has(routesGraph, fromTown)) {\n                routesGraph[fromTown].push({ [toTown]: cost });\n            } else {\n                routesGraph[fromTown] = [{ [toTown]: cost }];\n            }\n        }\n\n    });\n    return routesGraph;\n}\n\nconsole.log(createGraph(inputRoutesStr));\n\n\n\nfunction findRoutes(routeCovered, isVisitedNode, fromTown, toTown, maxStops, currentStops, aggDeliveryCost, currentCost, maxDeliveryCost, sameRoute) {\n\n    // summation cost\n    aggDeliveryCost = aggDeliveryCost + currentCost\n\n\n    // Initialization : routeRepeat - using if sameRoute is allowed twice or not \n    // Using {1} if same route is not allowed\n    // Using {3} if same route is allowed\n    let routeRepeat = 1\n\n    // If same route is allowed change condition - anything greater than 2\n\n    if (sameRoute) {\n        routeRepeat = 3\n    }\n\n    // Do not bother about empty route covered\n    if (routeCovered.trim().length > 0) {\n\n        // Marking the current path while traversel so that it should not run into stack overflow.\n        if (isVisitedNode[routeCovered]) {\n            isVisitedNode[routeCovered]++;\n        } else {\n            isVisitedNode[routeCovered] = 1\n        }\n\n\n        if (isVisitedNode[routeCovered] > routeRepeat) {\n            return;\n        }\n\n    }\n    // If aggregate cost is greater than upper cost limit return\n    if (aggDeliveryCost >= maxDeliveryCost) {\n        return\n    }\n\n    // Check if both from and to towns are same.(Destination reached)\n    if (fromTown == toTown) {\n        this.possibleRoutes++;                  // Increase number of possible routes\n        if (aggDeliveryCost <= this.cheapestDelivery) {\n            this.cheapestDelivery = aggDeliveryCost;\n        }\n\n        // If same route is allowed then do not return - let the program continue\n        if (!sameRoute)\n            return;\n\n    }\n\n    // If number of stops till now is greater than upper stops limit return\n    if (currentStops >= maxStops) {\n        return;\n    }\n    // Increase number of stops till now\n    currentStops++;\n\n    // Fetch the towns linked to fromTown from routesGraph created earlier.\n    let towns = this.routesGraph[fromTown];\n\n    // Loop over towns and do recursion.\n    for (let curr of towns) {\n        let cT = Object.keys(curr)[0];\n        let currentCost = curr[cT];\n\n\n        routeCovered = fromTown + cT;\n        this.findRoutes(routeCovered, isVisitedNode, cT, toTown, maxStops, currentStops, aggDeliveryCost, currentCost, maxDeliveryCost, sameRoute);\n\n        // Un-Marking current path \n        isVisitedNode[routeCovered]--;\n        if (isVisitedNode[routeCovered] < 0) {\n            isVisitedNode[routeCovered] = 0\n        }\n\n    }\n\n}\n\n\nfunction findNumberPossibleRoutes(start, dest, stops, sameRoute, maxDeliveryCost){\n    let fromTown = start || '';\n    let toTown = dest || '';\n     sameRoute = sameRoute || false;\n     maxDeliveryCost = maxDeliveryCost || Number.MAX_SAFE_INTEGER;\n    let maxStops = stops || Number.MAX_SAFE_INTEGER;\n\n\n    this.possibleRoutes = 0;\n    this.cheapestDelivery = Number.MAX_SAFE_INTEGER;\n\n    // Checking is one of the town is empty\n    if (fromTown.trim().length === 0 || toTown.trim().length === 0)\n        return 0;\n    fromTown = fromTown.toUpperCase();\n    toTown = toTown.toUpperCase();\n\n    let routes = this.routesGraph[fromTown];\n    let isVisitedNode = [];\n\n    let pathRoute = '';\n    for (let curr of routes) {\n        let currentTown = Object.keys(curr)[0];\n        let currentStops = 1;\n        let dC = curr[currentTown];\n        this.findRoutes(pathRoute, isVisitedNode, currentTown, toTown, maxStops, currentStops, dC, 0, maxDeliveryCost, sameRoute);\n    }\n    return this.possibleRoutes;\n}\n\nfindNumberPossibleRoutes('E' ,'D',4,true,0);"]},"metadata":{},"sourceType":"module"}