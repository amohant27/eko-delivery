{"ast":null,"code":"export default function getPossiblePaths(start, end, graph, visitRoute = '', count = 0) {\n  const edges = graph[start];\n  console.log('@@@@@@@@@@@@@@@');\n  console.log('START here', start);\n  console.log('edges1 for the above node', edges);\n\n  if (visitRoute && start === end) {\n    // We found the path\n    console.log('we found the path' + visitRoute + end + '=' + count);\n    return visitRoute + end + '=' + count;\n  }\n\n  if (!edges) {\n    console.log('we hit deadend , all nodes visited');\n    return '';\n  }\n\n  console.log('visitRoute - >', visitRoute);\n  console.log('last node visited', visitRoute[visitRoute.length - 1]);\n  console.log('current path to be traversed', visitRoute[visitRoute.length - 1] + start);\n  console.log('condition which we are checking if this path is visited', visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start));\n\n  if (visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start) >= 0) {\n    console.log('visitRoute if present index', visitRoute);\n    console.log(' already visited route we dont allow since it ll go in infiinte cycle');\n    return '';\n  }\n\n  visitRoute += start;\n  console.log('proceding to next node', visitRoute);\n  return Object.keys(edges).map(node => {\n    console.log('NODE', node, edges); // No 0 cost routes should be included as per requirements\n\n    if (edges[node] === 0) {\n      return '';\n    }\n\n    console.log('calling recursively with node , end, visitRoute', node, end);\n    const route = getPossiblePaths(node, end, graph, visitRoute, count + edges[node]);\n    console.log('****************************************');\n    return route;\n  }).filter(empty => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/possiblePath.js"],"names":["getPossiblePaths","start","end","graph","visitRoute","count","edges","console","log","length","indexOf","Object","keys","map","node","route","filter","empty","join"],"mappings":"AAAA,eAAe,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,GAAjC,EAAsCC,KAAtC,EAA6CC,UAAU,GAAG,EAA1D,EAA8DC,KAAK,GAAG,CAAtE,EAAyE;AACpF,QAAMC,KAAK,GAAGH,KAAK,CAACF,KAAD,CAAnB;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACAD,EAAAA,OAAO,CAACC,GAAR,CAAY,YAAZ,EAA0BP,KAA1B;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAY,2BAAZ,EAAyCF,KAAzC;;AAEA,MAAIF,UAAU,IAAIH,KAAK,KAAKC,GAA5B,EAAiC;AAC7B;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAY,sBAAqBJ,UAArB,GAAkCF,GAAlC,GAAwC,GAAxC,GAA8CG,KAA1D;AACA,WAAOD,UAAU,GAAGF,GAAb,GAAmB,GAAnB,GAAyBG,KAAhC;AACH;;AAED,MAAI,CAACC,KAAL,EAAY;AACRC,IAAAA,OAAO,CAACC,GAAR,CAAY,oCAAZ;AACA,WAAO,EAAP;AACH;;AACDD,EAAAA,OAAO,CAACC,GAAR,CAAY,gBAAZ,EAA8BJ,UAA9B;AACAG,EAAAA,OAAO,CAACC,GAAR,CAAY,mBAAZ,EAAiCJ,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAA3C;AACAF,EAAAA,OAAO,CAACC,GAAR,CAAY,8BAAZ,EAA4CJ,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,GAAoCR,KAAhF;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAY,yDAAZ,EAAuEJ,UAAU,CAACM,OAAX,CAAmBN,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,GAAoCR,KAAvD,CAAvE;;AACA,MAAIG,UAAU,CAACM,OAAX,CAAmBN,UAAU,CAACA,UAAU,CAACK,MAAX,GAAoB,CAArB,CAAV,GAAoCR,KAAvD,KAAiE,CAArE,EAAwE;AACpEM,IAAAA,OAAO,CAACC,GAAR,CAAY,6BAAZ,EAA2CJ,UAA3C;AACAG,IAAAA,OAAO,CAACC,GAAR,CAAY,uEAAZ;AACA,WAAO,EAAP;AACH;;AAGDJ,EAAAA,UAAU,IAAIH,KAAd;AACAM,EAAAA,OAAO,CAACC,GAAR,CAAY,wBAAZ,EAAsCJ,UAAtC;AAEA,SAAOO,MAAM,CAACC,IAAP,CAAYN,KAAZ,EAAmBO,GAAnB,CAAwBC,IAAD,IAAU;AACpCP,IAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAmBM,IAAnB,EAAwBR,KAAxB,EADoC,CAEpC;;AACA,QAAIA,KAAK,CAACQ,IAAD,CAAL,KAAgB,CAApB,EAAuB;AACnB,aAAO,EAAP;AACH;;AACDP,IAAAA,OAAO,CAACC,GAAR,CAAY,iDAAZ,EAA+DM,IAA/D,EAAqEZ,GAArE;AACA,UAAMa,KAAK,GAAGf,gBAAgB,CAACc,IAAD,EAAOZ,GAAP,EAAYC,KAAZ,EAAmBC,UAAnB,EAA+BC,KAAK,GAAGC,KAAK,CAACQ,IAAD,CAA5C,CAA9B;AACAP,IAAAA,OAAO,CAACC,GAAR,CAAY,0CAAZ;AACA,WAAOO,KAAP;AACH,GAVM,EAUJC,MAVI,CAUIC,KAAD,IAAW,CAAC,CAACA,KAVhB,EAUuBC,IAVvB,CAU4B,GAV5B,CAAP,CA9BoF,CAwC3C;AAC5C","sourcesContent":["export default function getPossiblePaths(start, end, graph, visitRoute = '', count = 0) {\n    const edges = graph[start];\n    console.log('@@@@@@@@@@@@@@@')\n    console.log('START here', start);\n    console.log('edges1 for the above node', edges);\n    \n    if (visitRoute && start === end) {\n        // We found the path\n        console.log('we found the path'+ visitRoute + end + '=' + count)\n        return visitRoute + end + '=' + count;\n    }\n\n    if (!edges) {\n        console.log('we hit deadend , all nodes visited')\n        return '';\n    }\n    console.log('visitRoute - >', visitRoute);\n    console.log('last node visited', visitRoute[visitRoute.length - 1]);\n    console.log('current path to be traversed', visitRoute[visitRoute.length - 1] + start);\n    console.log('condition which we are checking if this path is visited' ,visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start));\n    if (visitRoute.indexOf(visitRoute[visitRoute.length - 1] + start) >= 0) {\n        console.log('visitRoute if present index', visitRoute);\n        console.log(' already visited route we dont allow since it ll go in infiinte cycle');\n        return '';\n    }\n\n\n    visitRoute += start;\n    console.log('proceding to next node', visitRoute);\n\n    return Object.keys(edges).map((node) => {\n        console.log('NODE',node,edges);\n        // No 0 cost routes should be included as per requirements\n        if (edges[node] === 0) {\n            return '';\n        }  \n        console.log('calling recursively with node , end, visitRoute', node, end)\n        const route = getPossiblePaths(node, end, graph, visitRoute, count + edges[node]);\n        console.log('****************************************',);\n        return route;\n    }).filter((empty) => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}\n"]},"metadata":{},"sourceType":"module"}