{"ast":null,"code":"import _ from 'lodash'; // export const mainArr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\n// export const onlyRoutes = mainArr.map((item) => {\n//     return item.substring(0, 2);\n// })\n// var onlyStartPos = mainArr.map((item) => {\n//     return item.substring(0, 1);\n// });\n// let uniqueonlyStartPos = onlyStartPos.filter((item, i, ar) => ar.indexOf(item) === i);\n// var graphArr = {};\n// uniqueonlyStartPos.forEach((startPos) => {\n//     graphArr[startPos] = [];\n//     mainArr.forEach((route) => {\n//         if (route.charAt(0) === startPos) {\n//             var newObj = {};\n//             newObj[route.substring(1, 2)] = route.substring(2, route.length);\n//             graphArr[startPos].push(newObj);\n//         }\n//     })\n// });\n// const convertArrayToObject = (obj) => {\n//     var finalNeededObj = {};\n//     // eslint-disable-next-line \n//     Object.keys(obj).map((key) => {\n//         var eachObj = obj[key];\n//         var eachPair = {};\n//         for (var i = 0; i < eachObj.length; i++) {\n//             // eslint-disable-next-line \n//             Object.keys(eachObj[i]).map((key) => {\n//                 eachPair[key] = eachObj[i][key]\n//             })\n//         }\n//         finalNeededObj[key] = eachPair;\n//     })\n//     return finalNeededObj;\n// };\n// export const parsedInput = convertArrayToObject(graphArr);\n\nconst inputRoutesStr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\n\nfunction createGraph(inputRoutesStr) {\n  let routesGraph = {};\n\n  const inputRoutes = _.map(inputRoutesStr.split(','), _.trim);\n\n  _.forEach(inputRoutes, route => {\n    let fromTown = route.charAt(0).toUpperCase();\n    let toTown = route.charAt(1).toUpperCase();\n    let cost = parseInt(route.substr(2));\n\n    if (cost !== 0) {\n      if (_.has(routesGraph, fromTown)) {\n        routesGraph[fromTown].push({\n          [toTown]: cost\n        });\n      } else {\n        routesGraph[fromTown] = [{\n          [toTown]: cost\n        }];\n      }\n    }\n  });\n\n  return routesGraph;\n}\n\nconsole.log(createGraph(inputRoutesStr));","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/directedGraph.js"],"names":["_","inputRoutesStr","createGraph","routesGraph","inputRoutes","map","split","trim","forEach","route","fromTown","charAt","toUpperCase","toTown","cost","parseInt","substr","has","push","console","log"],"mappings":"AAAA,OAAOA,CAAP,MAAc,QAAd,C,CAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAIA,MAAMC,cAAc,GAAG,CAAC,KAAD,EAAQ,KAAR,EAAe,MAAf,EAAuB,KAAvB,EAA8B,KAA9B,EAAqC,KAArC,EAA4C,KAA5C,EAAmD,KAAnD,EAA0D,KAA1D,EAAiE,KAAjE,CAAvB;;AACA,SAASC,WAAT,CAAqBD,cAArB,EAAqC;AACjC,MAAIE,WAAW,GAAG,EAAlB;;AACA,QAAMC,WAAW,GAAGJ,CAAC,CAACK,GAAF,CAAMJ,cAAc,CAACK,KAAf,CAAqB,GAArB,CAAN,EAAiCN,CAAC,CAACO,IAAnC,CAApB;;AACAP,EAAAA,CAAC,CAACQ,OAAF,CAAUJ,WAAV,EAAwBK,KAAD,IAAW;AAC9B,QAAIC,QAAQ,GAAGD,KAAK,CAACE,MAAN,CAAa,CAAb,EAAgBC,WAAhB,EAAf;AACA,QAAIC,MAAM,GAAGJ,KAAK,CAACE,MAAN,CAAa,CAAb,EAAgBC,WAAhB,EAAb;AACA,QAAIE,IAAI,GAAGC,QAAQ,CAACN,KAAK,CAACO,MAAN,CAAa,CAAb,CAAD,CAAnB;;AACA,QAAIF,IAAI,KAAK,CAAb,EAAgB;AACZ,UAAId,CAAC,CAACiB,GAAF,CAAMd,WAAN,EAAmBO,QAAnB,CAAJ,EAAkC;AAC9BP,QAAAA,WAAW,CAACO,QAAD,CAAX,CAAsBQ,IAAtB,CAA2B;AAAE,WAACL,MAAD,GAAUC;AAAZ,SAA3B;AACH,OAFD,MAEO;AACHX,QAAAA,WAAW,CAACO,QAAD,CAAX,GAAwB,CAAC;AAAE,WAACG,MAAD,GAAUC;AAAZ,SAAD,CAAxB;AACH;AACJ;AAEJ,GAZD;;AAaA,SAAOX,WAAP;AACH;;AAEDgB,OAAO,CAACC,GAAR,CAAYlB,WAAW,CAACD,cAAD,CAAvB","sourcesContent":["import _ from 'lodash';\n\n\n// export const mainArr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\n// export const onlyRoutes = mainArr.map((item) => {\n//     return item.substring(0, 2);\n// })\n\n// var onlyStartPos = mainArr.map((item) => {\n//     return item.substring(0, 1);\n// });\n\n\n\n// let uniqueonlyStartPos = onlyStartPos.filter((item, i, ar) => ar.indexOf(item) === i);\n// var graphArr = {};\n// uniqueonlyStartPos.forEach((startPos) => {\n//     graphArr[startPos] = [];\n//     mainArr.forEach((route) => {\n//         if (route.charAt(0) === startPos) {\n//             var newObj = {};\n//             newObj[route.substring(1, 2)] = route.substring(2, route.length);\n//             graphArr[startPos].push(newObj);\n//         }\n//     })\n// });\n\n\n\n\n// const convertArrayToObject = (obj) => {\n//     var finalNeededObj = {};\n//     // eslint-disable-next-line \n//     Object.keys(obj).map((key) => {\n//         var eachObj = obj[key];\n//         var eachPair = {};\n//         for (var i = 0; i < eachObj.length; i++) {\n//             // eslint-disable-next-line \n//             Object.keys(eachObj[i]).map((key) => {\n//                 eachPair[key] = eachObj[i][key]\n\n//             })\n//         }\n//         finalNeededObj[key] = eachPair;\n//     })\n//     return finalNeededObj;\n// };\n\n\n// export const parsedInput = convertArrayToObject(graphArr);\n\n\n\nconst inputRoutesStr = ['AB1', 'AC4', 'AD10', 'BE3', 'CD4', 'CF2', 'DE1', 'EB3', 'EA2', 'FD1'];\nfunction createGraph(inputRoutesStr) {\n    let routesGraph = {}\n    const inputRoutes = _.map(inputRoutesStr.split(','), _.trim);\n    _.forEach(inputRoutes, (route) => {\n        let fromTown = route.charAt(0).toUpperCase();\n        let toTown = route.charAt(1).toUpperCase();\n        let cost = parseInt(route.substr(2));\n        if (cost !== 0) {\n            if (_.has(routesGraph, fromTown)) {\n                routesGraph[fromTown].push({ [toTown]: cost });\n            } else {\n                routesGraph[fromTown] = [{ [toTown]: cost }];\n            }\n        }\n\n    });\n    return routesGraph;\n}\n\nconsole.log(createGraph(inputRoutesStr));"]},"metadata":{},"sourceType":"module"}