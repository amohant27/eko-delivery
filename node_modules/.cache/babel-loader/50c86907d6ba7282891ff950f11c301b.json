{"ast":null,"code":"//inputGraph \n// A: { B: \"1\", C: \"4\", D: \"10\" }\n// B: { E: \"3\" }\n// C: { D: \"4\", F: \"2\" }\n// D: { E: \"1\" }\n// E: { B: \"3\", A: \"2\" }\n// F: { D: \"1\" }\nexport default function getPossiblePaths(start, end, inputGraph, visitedNodes = '', cost = 0) {\n  console.log(inputGraph);\n  const edges = inputGraph[start];\n\n  if (visitedNodes && start === end) {\n    // We found the route\n    console.log('we found the route' + visitedNodes + end + '=' + cost);\n    return visitedNodes + end + '=' + cost;\n  } // if no edges are found for a node, we return\n\n\n  if (!edges) {\n    console.log('we hit deadend , all nodes visited');\n    return '';\n  } //take the last visited node \n  //Add to startNode to check if the new VisitNode is visited already \n\n\n  let lastNodeVisited = visitedNodes[visitedNodes.length - 1];\n  let currNode = lastNodeVisited + start;\n\n  if (visitedNodes.indexOf(currNode) >= 0) {\n    console.log('this will go to infinite loop');\n    return '';\n  } //if  not visited , add in the curr visitNode\n\n\n  visitedNodes += start; //Iterate through all stations and its possible edges \n  //set the edge as the new Start \n  // Filter the routes (empty str) which had deadend\n\n  return Object.keys(edges).map(node => {\n    if (edges[node] === 0) {\n      return '';\n    }\n\n    const route = getPossiblePaths(node, end, inputGraph, visitedNodes, cost + edges[node] + ':');\n    return route;\n  }).filter(empty => !!empty).join(';');\n}","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/possiblePath.js"],"names":["getPossiblePaths","start","end","inputGraph","visitedNodes","cost","console","log","edges","lastNodeVisited","length","currNode","indexOf","Object","keys","map","node","route","filter","empty","join"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,GAAjC,EAAsCC,UAAtC,EAAkDC,YAAY,GAAG,EAAjE,EAAqEC,IAAI,GAAG,CAA5E,EAA+E;AAC1FC,EAAAA,OAAO,CAACC,GAAR,CAAYJ,UAAZ;AACA,QAAMK,KAAK,GAAGL,UAAU,CAACF,KAAD,CAAxB;;AACA,MAAIG,YAAY,IAAIH,KAAK,KAAKC,GAA9B,EAAmC;AAC/B;AACAI,IAAAA,OAAO,CAACC,GAAR,CAAY,uBAAsBH,YAAtB,GAAqCF,GAArC,GAA2C,GAA3C,GAAiDG,IAA7D;AACA,WAAOD,YAAY,GAAGF,GAAf,GAAqB,GAArB,GAA2BG,IAAlC;AACH,GAPyF,CAQ1F;;;AACA,MAAI,CAACG,KAAL,EAAY;AACRF,IAAAA,OAAO,CAACC,GAAR,CAAY,oCAAZ;AACA,WAAO,EAAP;AACH,GAZyF,CAa1F;AACA;;;AACA,MAAIE,eAAe,GAAGL,YAAY,CAACA,YAAY,CAACM,MAAb,GAAsB,CAAvB,CAAlC;AACA,MAAIC,QAAQ,GAAGF,eAAe,GAACR,KAA/B;;AAEA,MAAIG,YAAY,CAACQ,OAAb,CAAqBD,QAArB,KAAkC,CAAtC,EAAyC;AACrCL,IAAAA,OAAO,CAACC,GAAR,CAAY,+BAAZ;AACA,WAAO,EAAP;AACH,GArByF,CAuB1F;;;AACAH,EAAAA,YAAY,IAAIH,KAAhB,CAxB0F,CA0B1F;AACA;AACA;;AAEA,SAAOY,MAAM,CAACC,IAAP,CAAYN,KAAZ,EAAmBO,GAAnB,CAAwBC,IAAD,IAAU;AACpC,QAAIR,KAAK,CAACQ,IAAD,CAAL,KAAgB,CAApB,EAAuB;AACnB,aAAO,EAAP;AACH;;AACD,UAAMC,KAAK,GAAGjB,gBAAgB,CAACgB,IAAD,EAAOd,GAAP,EAAYC,UAAZ,EAAwBC,YAAxB,EAAsCC,IAAI,GAAGG,KAAK,CAACQ,IAAD,CAAZ,GAAoB,GAA1D,CAA9B;AACA,WAAOC,KAAP;AACH,GANM,EAMJC,MANI,CAMIC,KAAD,IAAW,CAAC,CAACA,KANhB,EAMuBC,IANvB,CAM4B,GAN5B,CAAP;AAOH","sourcesContent":["//inputGraph \n// A: { B: \"1\", C: \"4\", D: \"10\" }\n// B: { E: \"3\" }\n// C: { D: \"4\", F: \"2\" }\n// D: { E: \"1\" }\n// E: { B: \"3\", A: \"2\" }\n// F: { D: \"1\" }\nexport default function getPossiblePaths(start, end, inputGraph, visitedNodes = '', cost = 0) {\n    console.log(inputGraph)\n    const edges = inputGraph[start]; \n    if (visitedNodes && start === end) {\n        // We found the route\n        console.log('we found the route'+ visitedNodes + end + '=' + cost)\n        return visitedNodes + end + '=' + cost;\n    }\n    // if no edges are found for a node, we return\n    if (!edges) {\n        console.log('we hit deadend , all nodes visited')\n        return '';\n    }\n    //take the last visited node \n    //Add to startNode to check if the new VisitNode is visited already \n    let lastNodeVisited = visitedNodes[visitedNodes.length - 1];\n    let currNode = lastNodeVisited+start;\n    \n    if (visitedNodes.indexOf(currNode) >= 0) {\n        console.log('this will go to infinite loop');\n        return '';\n    }\n\n    //if  not visited , add in the curr visitNode\n    visitedNodes += start;\n\n    //Iterate through all stations and its possible edges \n    //set the edge as the new Start \n    // Filter the routes (empty str) which had deadend\n\n    return Object.keys(edges).map((node) => {\n        if (edges[node] === 0) {\n            return '';\n        }  \n        const route = getPossiblePaths(node, end, inputGraph, visitedNodes, cost + edges[node] +':');\n        return route;\n    }).filter((empty) => !!empty).join(';'); \n}\n"]},"metadata":{},"sourceType":"module"}