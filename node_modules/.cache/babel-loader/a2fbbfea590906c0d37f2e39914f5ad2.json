{"ast":null,"code":"export default function getPossiblePaths(start, end, inputGraph, visitedNodes = '', cost = 0) {\n  const edges = inputGraph[start];\n\n  if (visitedNodes && start === end) {\n    // We found the path\n    console.log('we found the path' + visitedNodes + end + '=' + cost);\n    return visitedNodes + end + '=' + cost;\n  }\n\n  if (!edges) {\n    console.log('we hit deadend , all nodes visited');\n    return '';\n  }\n\n  let lastNodeVisited;\n\n  if (visitedNodes.indexOf(visitedNodes[visitedNodes.length - 1] + start) >= 0) {\n    console.log('visitedNodes if present index', visitedNodes);\n    console.log(' already visited route we dont allow since it ll go in infiinte cycle');\n    return '';\n  }\n\n  visitedNodes += start;\n  return Object.keys(edges).map(node => {\n    console.log('NODE', node, edges); // No 0 cost routes should be included as per requirements\n\n    if (edges[node] === 0) {\n      return '';\n    }\n\n    const route = getPossiblePaths(node, end, inputGraph, visitedNodes, cost + edges[node] + ':');\n    return route;\n  }).filter(empty => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}","map":{"version":3,"sources":["/Users/ananya/Documents/Learnings/Coding/Eko_Delivery/my-app/src/util/possiblePath.js"],"names":["getPossiblePaths","start","end","inputGraph","visitedNodes","cost","edges","console","log","lastNodeVisited","indexOf","length","Object","keys","map","node","route","filter","empty","join"],"mappings":"AAAA,eAAe,SAASA,gBAAT,CAA0BC,KAA1B,EAAiCC,GAAjC,EAAsCC,UAAtC,EAAkDC,YAAY,GAAG,EAAjE,EAAqEC,IAAI,GAAG,CAA5E,EAA+E;AAC1F,QAAMC,KAAK,GAAGH,UAAU,CAACF,KAAD,CAAxB;;AAGA,MAAIG,YAAY,IAAIH,KAAK,KAAKC,GAA9B,EAAmC;AAC/B;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAY,sBAAqBJ,YAArB,GAAoCF,GAApC,GAA0C,GAA1C,GAAgDG,IAA5D;AACA,WAAOD,YAAY,GAAGF,GAAf,GAAqB,GAArB,GAA2BG,IAAlC;AACH;;AAED,MAAI,CAACC,KAAL,EAAY;AACRC,IAAAA,OAAO,CAACC,GAAR,CAAY,oCAAZ;AACA,WAAO,EAAP;AACH;;AACD,MAAIC,eAAJ;;AACA,MAAIL,YAAY,CAACM,OAAb,CAAqBN,YAAY,CAACA,YAAY,CAACO,MAAb,GAAsB,CAAvB,CAAZ,GAAwCV,KAA7D,KAAuE,CAA3E,EAA8E;AAC1EM,IAAAA,OAAO,CAACC,GAAR,CAAY,+BAAZ,EAA6CJ,YAA7C;AACAG,IAAAA,OAAO,CAACC,GAAR,CAAY,uEAAZ;AACA,WAAO,EAAP;AACH;;AAGDJ,EAAAA,YAAY,IAAIH,KAAhB;AAEA,SAAOW,MAAM,CAACC,IAAP,CAAYP,KAAZ,EAAmBQ,GAAnB,CAAwBC,IAAD,IAAU;AACpCR,IAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAmBO,IAAnB,EAAwBT,KAAxB,EADoC,CAEpC;;AACA,QAAIA,KAAK,CAACS,IAAD,CAAL,KAAgB,CAApB,EAAuB;AACnB,aAAO,EAAP;AACH;;AACD,UAAMC,KAAK,GAAGhB,gBAAgB,CAACe,IAAD,EAAOb,GAAP,EAAYC,UAAZ,EAAwBC,YAAxB,EAAsCC,IAAI,GAAGC,KAAK,CAACS,IAAD,CAAZ,GAAoB,GAA1D,CAA9B;AAEA,WAAOC,KAAP;AACH,GATM,EASJC,MATI,CASIC,KAAD,IAAW,CAAC,CAACA,KAThB,EASuBC,IATvB,CAS4B,GAT5B,CAAP,CAxB0F,CAiCjD;AAC5C","sourcesContent":["export default function getPossiblePaths(start, end, inputGraph, visitedNodes = '', cost = 0) {\n    const edges = inputGraph[start];\n   \n    \n    if (visitedNodes && start === end) {\n        // We found the path\n        console.log('we found the path'+ visitedNodes + end + '=' + cost)\n        return visitedNodes + end + '=' + cost;\n    }\n\n    if (!edges) {\n        console.log('we hit deadend , all nodes visited')\n        return '';\n    }\n    let lastNodeVisited\n    if (visitedNodes.indexOf(visitedNodes[visitedNodes.length - 1] + start) >= 0) {\n        console.log('visitedNodes if present index', visitedNodes);\n        console.log(' already visited route we dont allow since it ll go in infiinte cycle');\n        return '';\n    }\n\n\n    visitedNodes += start;\n\n    return Object.keys(edges).map((node) => {\n        console.log('NODE',node,edges);\n        // No 0 cost routes should be included as per requirements\n        if (edges[node] === 0) {\n            return '';\n        }  \n        const route = getPossiblePaths(node, end, inputGraph, visitedNodes, cost + edges[node] +':');\n      \n        return route;\n    }).filter((empty) => !!empty).join(';'); // Filter the routes (empty str) which had deadend\n}\n"]},"metadata":{},"sourceType":"module"}